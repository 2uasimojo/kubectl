# ConfigMaps and Secrets

{% panel style="info", title="TL;DR" %}
- Generate Secrets and Configmaps from files and literals
- Rolling out changes to Secrets and ConfigMaps
{% endpanel %}

## Motivation

The source of truth for ConfigMap and Secret Resources typically resides somewhere else, such as a `.properties`
or `.pem` file.  Apply offers native support for generating both ConfigMaps and Secrets from other sources
such as files, literals and command outputs.

Additionally, ConfigMaps and Secrets require roll outs to be performed differently than for most
other Resources in order for the changes to be rolled out to Pods consuming them.

## Generators

ConfigMap and Secret Resources can be generated by adding `configMapGenerator` and `secretGenerator`
entries to the `apply.yaml` file.  `configMapGenerator` and `secretGenerator` each take a list of items.
Each item generates a different Resources.

**The generated Resources name's will have suffixes as hashes of their data.  See [Rollouts](#rollouts) for more on this.**

### ConfigMaps From Files

{% method %}
ConfigMap Resources may be generated from files - such as a java `.properties` file.  To generate a ConfigMap
Resource for a file, add an entry to `configMapGenerator` with the filename.

**Example:** Generate a ConfigMap with a data item containing the contents of a file.

The ConfigMaps will have data values populated from the file contents.  The contents of each file will
appear as a single data item in the ConfigMap keyed by the filename.

{% sample lang="yaml" %}
**Input:** The apply.yaml file

```yaml
# apply.yaml
configMapGenerator:
- name: myApplicationProperties
  files:
  - application.properties
  
# application.properties
FOO=Bar
```

**Applied:** The Resource that is Applied to the cluster

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  # The name has had a suffix applied
  name: myApplicationProperties-c79528k426
# The data has been populated from each file's contents
data:
  application.properties: |
    FOO=Bar
```
{% endmethod %}

### ConfigMaps From Literals

ConfigMap Resources may be generated from literal key-value pairs - such as `JAVA_HOME=/opt/java/jdk`.
To generate a ConfigMap Resource from literal key-value pairs, add an entry to `configMapGenerator` with a
list of `literals`.

{% panel style="info", title="Literal Syntax" %}
- The key/value are separated by a `=` sign (left side is the key)
- The value of each literal will appear as a data item in the ConfigMap keyed by its key.
{% endpanel %}

{% method %}
**Example:** Create a ConfigMap with 2 data items generated from literals.

{% sample lang="yaml" %}
**Input:** The apply.yaml file

```yaml
# apply.yaml
configMapGenerator:
- name: myJavaServerEnvVars
  literals:	
  - JAVA_HOME=/opt/java/jdk
  - JAVA_TOOL_OPTIONS=-agentlib:hprof
```

**Applied:** The Resource that is Applied to the cluster

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  # The name has had a suffix applied
  name: myJavaServerEnvVars-k44mhd6h5f
# The data has been populated from each literal pair
data:
  JAVA_HOME: /opt/java/jdk
  JAVA_TOOL_OPTIONS: -agentlib:hprof
```
{% endmethod %}

### Secrets from Commands

Secret Resources may be generated from commands that output the data items.  Commands may simply output
the contents of a file as data, but may do more complicate actions such as fetching data from a remote
location, or decrypting files.

{% panel style="info", title="Secret Syntax" %}
- Secret type is set using the `type` field.
- Timeout for the command output maybe set using the `timeoutSeconds` field.
{% endpanel %}

{% method %}
**Example:** Generate a `kubernetes.io/tls` Secret from local files

{% sample lang="yaml" %}
**Input:** The apply.yaml file

```yaml
# apply.yaml
secretGenerator:
- name: app-tls
  commands:
    tls.crt: "cat secret/tls.cert"
    tls.key: "cat secret/tls.key"
  type: "kubernetes.io/tls"
```

**Applied:** The Resource that is Applied to the cluster

```yaml
apiVersion: v1
kind: Secret
metadata:
  # The name has had a suffix applied
  name: app-tls-4tc9tcbd8k
type: kubernetes.io/tls
# The data has been populated from each command's output
data:
  tls.crt: LS0tLS1CRUd...tCg==
  tls.key: LS0tLS1CRUd...0tLQo=
```
{% endmethod %}

{% method %}

**Example:** Generate an `Opaque` Secret from downloading remote files

{% sample lang="yaml" %}
**Input:** The apply.yaml file

```yaml
# apply.yaml
secretGenerator:
- name: downloaded_secret
  timeoutSeconds: 30
  commands:
    username: "curl -s https://path/to/username"
    password: "curl -s https://path/to/password"
  type: "kubernetes.io/tls"
```

**Applied:** The Resource that is Applied to the cluster.

```yaml
apiVersion: v1
kind: Secret
metadata:
  # The name has had a suffix applied
  name: downloaded_secret-gm74hh58b5
type: Opaque
# The data has been populated from each command's output
data:
  password: YmFyCg==
  username: Zm9vCg==
```
{% endmethod %}

### Secrets from Env Commands

Secret Resources may also be generated from commands that output multiple data items as key value pairs.
This is useful for encoding the elements of Docker .env files or .ini files as separate data items within
Secrets.

{% panel style="info", title="Commands vs EnvCommands" %}
The difference between `commands` and `envCommand` is that **with a command, each item creates a different data
item** whereas **with an envCommand each output line creates a different data item.**
{% endpanel %}

{% method %}
**Example:** Generate an `Opaque` Secret from the environment

{% sample lang="yaml" %}
**Input:** The apply.yaml file

```yaml
# apply.yaml
secretGenerator:
- name: env_file_secret
  envCommand: printf "DB_USERNAME=admin\nDB_PASSWORD=somepw"
  type: Opaque
```

**Applied:** The Resource that is Applied to the cluster.

```yaml
apiVersion: v1
kind: Secret
metadata:
  # The name has had a suffix applied
  name: env_file_secret-hc4d62fgb8
type: Opaque
# The data has been populated from the command output lines
data:
  DB_PASSWORD: c29tZXB3
  DB_USERNAME: YWRtaW4=
```
{% endmethod %}

### Propagating the Name Suffix

{% method %}
Workloads that reference the ConfigMap or Secret will need to know the name of the generated Resource
including the suffix, however Apply solves this automatically for users.  Apply will identify
references to generated ConfigMaps and Secrets, and update their them.

The generated ConfigMap name will be `myJavaServerEnvVars` with a suffix unique to its contents.
Changes to the contents will change the name suffix, resulting in the creation of a new ConfigMap.

The PodTemplate volume references the ConfigMap by the name specified in the generator (excluding the suffix).
Apply will update the name to include the suffix applied to the ConfigMap name.

{% sample lang="yaml" %}
**Input:** The apply.yaml and deployment.yaml files

```yaml
# apply.yaml
configMapGenerator:
- name: myJavaServerEnvVars
  literals:	
  - JAVA_HOME=/opt/java/jdk
  - JAVA_TOOL_OPTIONS=-agentlib:hprof
resources:
- deployment.yaml

# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment
  labels:
    app: test
spec:
  selector:
    matchLabels:
      app: test
  template:
    metadata:
      labels:
        app: test
    spec:
      containers:
      - name: container
        image: k8s.gcr.io/busybox
        command: [ "/bin/sh", "-c", "ls /etc/config/" ]
        volumeMounts:
        - name: config-volume
          mountPath: /etc/config
      volumes:
      - name: config-volume
        configMap:
          name: myJavaServerEnvVars
```

**Applied:** The Resources that are Applied to the cluster.

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  # The name has been updated to include the suffix
  name: myJavaServerEnvVars-k44mhd6h5f
data:
  JAVA_HOME: /opt/java/jdk
  JAVA_TOOL_OPTIONS: -agentlib:hprof
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: test
  name: test-deployment
spec:
  selector:
    matchLabels:
      app: test
  template:
    metadata:
      labels:
        app: test
    spec:
      containers:
      - command:
        - /bin/sh
        - -c
        - ls /etc/config/
        image: k8s.gcr.io/busybox
        name: container
        volumeMounts:
        - mountPath: /etc/config
          name: config-volume
      volumes:
      - configMap:
          # The name has been updated to include the
          # suffix matching the ConfigMap
          name: myJavaServerEnvVars-k44mhd6h5f
        name: config-volume
```
{% endmethod %}

## Rollouts

ConfigMap and Secret values are consumed by Pods as: environment variables, commandline arguments and files.

This is important because Updating a ConfigMap or Secret will:

- immediately update the files mounted by *all* Pods consuming them
- not update the environment variables or commandline arguments until the Pod is restarted
 
Typically users want to perform a rolling update of the ConfigMap or Secret changes to Pods as soon as
the ConfigMap or Secret changes are pushed.

Apply facilitates rolling updates for ConfigMaps and Secrets by creating a new ConfigMap or Secret
for each change to the data.  Workloads (e.g. Deployments, StatefulSets, etc) are updated to point to a new
ConfigMap or Secret instead of the old one.  This allows the change to be gradually rolled the same way
other Pod Template changes are rolled out.

Each generated Resources name has a suffix appended by hashing the contents.  This approach ensures a new
ConfigMap or Secret is generated each time the contents is modified.

**Note:** Because the Resource names will contain a suffix, when looking for them with `kubectl get`,
their names will not match exactly what is specified in the apply.yaml file.

### Deletion and Cleanup

Apply will not automatically delete generated ConfigMaps or Secrets as long as they are in use by Resources within
the project. This may mean that they are not deleted until Apply is run again after the rollouts are complete.
e.g. both the old ConfigMap and new ConfigMap will continue to exist until only the new ConfigMap is used and Apply is
run again.

{% panel style="info", title="Blocking Apply" %}
If Apply is run with `--wait` it will block until the Rollouts have completed.  In this situtation, the old generated
ConfigMaps and Secrets should not longer be in use, and will be deleted by Apply before exiting.
{% endpanel %}